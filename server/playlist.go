package hms

import (
	"bufio"
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"github.com/google/uuid"
	"gopkg.in/ini.v1"
)

type Track struct {
	Title    string
	Location string
	Duration int64 // duration in milliseconds
}

type Playlist struct {
	Tracks []Track
	Dest   string // playlist file destination
	// playlist description
	Title  string
	Group  string
	Album  string
	Artist string
	Genre  string
	Image  string
}

// Generated by https://www.onlinetool.io/xmltogo/

const xmlindent = "    "

type WplMeta struct {
	Text    string `xml:",chardata"`
	Name    string `xml:"name,attr"`
	Content string `xml:"content,attr"`
}

type WplMedia struct {
	Text string `xml:",chardata"`
	Src  string `xml:"src,attr"`
	Tid  string `xml:"tid,attr,omitempty"`
}

type Wpl struct {
	XMLName xml.Name `xml:"smil"`
	Text    string   `xml:",chardata"`
	Head    struct {
		Text  string    `xml:",chardata"`
		Meta  []WplMeta `xml:"meta"`
		Title string    `xml:"title"`
	} `xml:"head"`
	Body struct {
		Text string `xml:",chardata"`
		Seq  struct {
			Text  string     `xml:",chardata"`
			Media []WplMedia `xml:"media"`
		} `xml:"seq"`
	} `xml:"body"`
}

type AsxParam struct {
	Text  string `xml:",chardata"`
	Name  string `xml:"name,attr"`
	Value string `xml:"value,attr"`
}

type AsxEntry struct {
	Text  string `xml:",chardata"`
	Title string `xml:"title,omitempty"`
	Ref   struct {
		Href string `xml:"href,attr"`
	} `xml:"ref"`
	Duration struct {
		Value string `xml:"value,attr"`
	} `xml:"duration"`
	Param     []AsxParam `xml:"param"`
	Author    string     `xml:"author,omitempty"`
	Copyright string     `xml:"copyright,omitempty"`
}

type Asx struct {
	XMLName xml.Name   `xml:"asx"`
	Text    string     `xml:",chardata"`
	Version string     `xml:"version,attr"`
	Title   string     `xml:"title,omitempty"`
	Param   []AsxParam `xml:"param"`
	Entry   []AsxEntry `xml:"entry"`
}

type XspfTrack struct {
	Text     string `xml:",chardata"`
	Location string `xml:"location"`
	Title    string `xml:"title,omitempty"`
	Duration int64  `xml:"duration,omitempty"`
}

// https://www.xspf.org/
type Xspf struct {
	XMLName xml.Name    `xml:"playlist"`
	Text    string      `xml:",chardata"`
	Version string      `xml:"version,attr"`
	Xmlns   string      `xml:"xmlns,attr"`
	Title   string      `xml:"title,omitempty"`
	Track   []XspfTrack `xml:"trackList>track"`
}

var (
	ErrM3USign = errors.New("file does not starts with M3U signature")
)

func isURL(fpath string) bool {
	return strings.HasPrefix(fpath, "http://") || strings.HasPrefix(fpath, "https://")
}

func ToHHMMSS(dur int64) string {
	var ms = dur % 1000
	var ss = (dur / 1000) % 60
	var mm = (dur / 60000) % 60
	var hh = dur / 3600000
	var s string
	if hh > 0 {
		s = fmt.Sprintf("%02d:%02d:%02d", hh, mm, ss)
	} else if mm > 0 {
		s = fmt.Sprintf("%02d:%02d", mm, ss)
	} else {
		s = fmt.Sprintf("%d", ss)
	}
	if ms > 0 {
		s += fmt.Sprintf(".%03d", ms)
	}
	return s
}

func FromHHMMSS(dur string) int64 {
	var a = strings.Split(dur, ".")
	var ms int
	if len(a) > 1 {
		ms, _ = strconv.Atoi(a[1])
		for i := len(a[1]); i < 3; i++ {
			ms *= 10
		}
	}
	a = strings.Split(a[0], ":")
	if len(a) > 2 {
		var hh, _ = strconv.Atoi(a[0])
		var mm, _ = strconv.Atoi(a[1])
		var ss, _ = strconv.Atoi(a[2])
		ms += hh*3600000 + mm*60000 + ss*1000
	} else if len(a) > 1 {
		var mm, _ = strconv.Atoi(a[0])
		var ss, _ = strconv.Atoi(a[1])
		ms += mm*60000 + ss*1000
	} else {
		var ss, _ = strconv.Atoi(a[0])
		ms += ss * 1000
	}
	return int64(ms)
}

func (pl *Playlist) AbsPath(fpath string) string {
	if len(fpath) == 0 {
		fpath = "."
	}
	if strings.HasPrefix(fpath, "file:///") {
		return fpath[8:]
	}
	if filepath.IsAbs(fpath) || isURL(fpath) {
		return fpath
	} else if fpath[0] == filepath.Separator {
		return filepath.Join(filepath.VolumeName(pl.Dest), fpath)
	} else {
		return filepath.Join(pl.Dest, fpath)
	}
}

func (pl *Playlist) ReadFrom(r io.Reader) (num int64, err error) {
	return pl.ReadM3U(r)
}

func (pl *Playlist) WriteTo(w io.Writer) (num int64, err error) {
	return pl.WriteM3U(w)
}

var extinfre = regexp.MustCompile(`^#EXTINF:\s*(\d+),\s*(.*)$`)
var plistre = regexp.MustCompile(`^#PLAYLIST:\s*(.*)$`)
var grpre = regexp.MustCompile(`^#EXTGRP:\s*(.*)$`)
var albre = regexp.MustCompile(`^#EXTALB:\s*(.*)$`)
var artre = regexp.MustCompile(`^#EXTART:\s*(.*)$`)
var genrere = regexp.MustCompile(`^#EXTGENRE:\s*(.*)$`)
var imgre = regexp.MustCompile(`^#EXTIMG:\s*(.*)$`)

func (pl *Playlist) ReadM3U(r io.Reader) (num int64, err error) {
	var buf = bufio.NewReader(r)
	var line string

	var readline = func() {
		for {
			line, err = buf.ReadString('\n')
			num += int64(len(line))
			if err != nil {
				if err == io.EOF {
					err = nil
				}
				return
			}
			line = strings.TrimSpace(line)
			if len(line) > 0 {
				break
			}
		}
	}

	if readline(); err != nil {
		return
	}
	if line != "#EXTM3U" && line != utf8bom+"#EXTM3U" {
		return 0, ErrM3USign
	}

	var match []string
	for {
		var track Track

		if readline(); err != nil || len(line) == 0 {
			return
		}

		match = extinfre.FindStringSubmatch(line)
		if match != nil {
			var sec int64
			if sec, err = strconv.ParseInt(match[1], 10, 0); err != nil {
				return
			}
			if sec >= 0 {
				track.Duration = sec * 1000
			} else {
				track.Duration = -1
			}
			track.Title = match[2]

			if readline(); err != nil || len(line) == 0 {
				return
			}
			track.Location = pl.AbsPath(line)
			pl.Tracks = append(pl.Tracks, track)
			continue
		}

		match = plistre.FindStringSubmatch(line)
		if match != nil {
			pl.Title = match[1]
			continue
		}

		match = grpre.FindStringSubmatch(line)
		if match != nil {
			pl.Group = match[1]
			continue
		}

		match = albre.FindStringSubmatch(line)
		if match != nil {
			pl.Album = match[1]
			continue
		}

		match = artre.FindStringSubmatch(line)
		if match != nil {
			pl.Artist = match[1]
			continue
		}

		match = genrere.FindStringSubmatch(line)
		if match != nil {
			pl.Genre = match[1]
			continue
		}

		match = imgre.FindStringSubmatch(line)
		if match != nil {
			pl.Image = match[1]
			continue
		}

		if strings.HasPrefix(line, "#") { // any other comment
			continue
		} else {
			track.Location = pl.AbsPath(line)
			pl.Tracks = append(pl.Tracks, track)
		}
	}
}

func (pl *Playlist) WriteM3U(w io.Writer) (num int64, err error) {
	var n int
	n, err = fmt.Fprintln(w, "#EXTM3U")
	num += int64(n)
	if err != nil {
		return
	}

	if len(pl.Title) > 0 {
		n, err = fmt.Fprintf(w, "#PLAYLIST:%s\n", pl.Title)
		num += int64(n)
		if err != nil {
			return
		}
	}

	if len(pl.Group) > 0 {
		n, err = fmt.Fprintf(w, "#EXTGRP:%s\n", pl.Group)
		num += int64(n)
		if err != nil {
			return
		}
	}

	if len(pl.Album) > 0 {
		n, err = fmt.Fprintf(w, "#EXTALB:%s\n", pl.Album)
		num += int64(n)
		if err != nil {
			return
		}
	}

	if len(pl.Artist) > 0 {
		n, err = fmt.Fprintf(w, "#EXTART:%s\n", pl.Artist)
		num += int64(n)
		if err != nil {
			return
		}
	}

	if len(pl.Genre) > 0 {
		n, err = fmt.Fprintf(w, "#EXTGENRE:%s\n", pl.Genre)
		num += int64(n)
		if err != nil {
			return
		}
	}

	if len(pl.Image) > 0 {
		n, err = fmt.Fprintf(w, "#EXTIMG:%s\n", pl.Image)
		num += int64(n)
		if err != nil {
			return
		}
	}

	const sep = string(filepath.Separator)
	var dir0 = filepath.Clean(pl.Dest)
	var dir1 = filepath.Dir(dir0)
	dir0 += sep
	dir1 += sep
	for _, track := range pl.Tracks {
		if track.Duration != 0 {
			var sec int64
			if track.Duration > 0 {
				sec = track.Duration / 1000
			} else {
				sec = -1
			}
			n, err = fmt.Fprintf(w, "#EXTINF:%d,%s\n", sec, track.Title)
			num += int64(n)
			if err != nil {
				return
			}
		}

		var fpath = track.Location
		if strings.HasPrefix(fpath, dir0) || strings.HasPrefix(fpath, dir1) {
			if fpath, err = filepath.Rel(dir0, fpath); err != nil {
				return
			}
		}
		n, err = fmt.Fprintln(w, fpath)
		num += int64(n)
		if err != nil {
			return
		}
	}
	return
}

func (pl *Playlist) WriteM3U8(w io.Writer) (num int64, err error) {
	var n int
	var n64 int64
	n, err = w.Write(S2B(utf8bom))
	num += int64(n)
	if err != nil {
		return
	}
	n64, err = pl.WriteM3U(w)
	num += n64
	return
}

func (pl *Playlist) ReadWPL(r io.Reader) (num int64, err error) {
	var body []byte
	if body, err = io.ReadAll(r); err != nil {
		return
	}
	num = int64(len(body))

	var wpl Wpl
	if err = xml.Unmarshal(body, &wpl); err != nil {
		return
	}

	for _, v := range wpl.Body.Seq.Media {
		var track Track
		track.Title = filepath.Base(v.Src)
		track.Location = pl.AbsPath(v.Src)
		pl.Tracks = append(pl.Tracks, track)
	}
	return
}

func (pl *Playlist) WriteWPL(w io.Writer) (num int64, err error) {
	var n int
	n, err = fmt.Fprintln(w, `<?wpl version="1.0"?>`)
	num += int64(n)
	if err != nil {
		return
	}

	var wpl Wpl
	wpl.Head.Title = pl.Title
	wpl.Head.Meta = append(wpl.Head.Meta, WplMeta{Name: "Generator", Content: "Home Media Server"})
	wpl.Head.Meta = append(wpl.Head.Meta, WplMeta{Name: "ItemCount", Content: fmt.Sprintf("%d", len(pl.Tracks))})

	const sep = string(filepath.Separator)
	var dir0 = filepath.Clean(pl.Dest)
	var dir1 = filepath.Dir(dir0)
	dir0 += sep
	dir1 += sep
	for _, track := range pl.Tracks {
		var fpath = track.Location
		if strings.HasPrefix(fpath, dir0) || strings.HasPrefix(fpath, dir1) {
			if fpath, err = filepath.Rel(dir0, fpath); err != nil {
				return
			}
		}
		var id = uuid.NewSHA1(uuid.NameSpaceURL, S2B(fpath)).String()
		wpl.Body.Seq.Media = append(wpl.Body.Seq.Media, WplMedia{Src: fpath, Tid: "{" + id + "}"})
	}

	var body []byte
	if body, err = xml.MarshalIndent(&wpl, "", xmlindent); err != nil {
		return
	}
	n, err = w.Write(body)
	num = int64(n)
	return
}

func (pl *Playlist) ReadPLS(r io.Reader) (num int64, err error) {
	var file *ini.File
	if file, err = ini.Load(r); err != nil {
		return
	}

	var pls *ini.Section
	if pls, err = file.GetSection("playlist"); err != nil {
		return
	}

	var key *ini.Key
	if key, err = pls.GetKey("NumberOfEntries"); err != nil {
		return
	}
	var count int64
	if count, err = key.Int64(); err != nil {
		return
	}

	for i := int64(1); i <= count; i++ {
		var track Track
		var sn = strconv.FormatInt(i, 10)

		if key, err = pls.GetKey("Length" + sn); err != nil {
			return
		}
		var sec int64
		if sec, err = key.Int64(); err != nil {
			return
		}
		if sec >= 0 {
			track.Duration = sec * 1000
		} else {
			track.Duration = -1
		}

		if key, err = pls.GetKey("Title" + sn); err != nil {
			return
		}
		track.Title = key.String()

		if key, err = pls.GetKey("File" + sn); err != nil {
			return
		}
		track.Location = pl.AbsPath(key.String())

		pl.Tracks = append(pl.Tracks, track)
	}
	return
}

func (pl *Playlist) WritePLS(w io.Writer) (num int64, err error) {
	var n int
	n, err = fmt.Fprintln(w, `[playlist]`)
	num += int64(n)
	if err != nil {
		return
	}
	const sep = string(filepath.Separator)
	var dir0 = filepath.Clean(pl.Dest)
	var dir1 = filepath.Dir(dir0)
	dir0 += sep
	dir1 += sep
	for i, track := range pl.Tracks {
		var fpath = track.Location
		if strings.HasPrefix(fpath, dir0) || strings.HasPrefix(fpath, dir1) {
			if fpath, err = filepath.Rel(dir0, fpath); err != nil {
				return
			}
		}
		n, err = fmt.Fprintf(w, "File%d=%s\n", i, fpath)
		num += int64(n)
		if err != nil {
			return
		}
		if len(track.Title) > 0 {
			n, err = fmt.Fprintf(w, "Title%d=%s\n", i, track.Title)
			num += int64(n)
			if err != nil {
				return
			}
		}
		if track.Duration != 0 {
			var sec int64
			if track.Duration > 0 {
				sec = track.Duration / 1000
			} else {
				sec = -1
			}
			n, err = fmt.Fprintf(w, "Length%d=%d\n", i, sec)
			num += int64(n)
			if err != nil {
				return
			}
		}
	}

	n, err = fmt.Fprintf(w, "NumberOfEntries=%d\n", len(pl.Tracks))
	num += int64(n)
	if err != nil {
		return
	}

	n, err = fmt.Fprintln(w, "Version=2")
	num += int64(n)
	if err != nil {
		return
	}
	return
}

func (pl *Playlist) ReadASX(r io.Reader) (num int64, err error) {
	var body []byte
	if body, err = io.ReadAll(r); err != nil {
		return
	}
	num = int64(len(body))

	var asx Asx
	if err = xml.Unmarshal(body, &asx); err != nil {
		return
	}

	pl.Title = asx.Title

	for _, v := range asx.Entry {
		var track Track
		track.Title = v.Title
		track.Location = pl.AbsPath(v.Ref.Href)
		if len(v.Duration.Value) > 0 {
			if v.Duration.Value == "-1" {
				track.Duration = -1
			} else {
				track.Duration = FromHHMMSS(v.Duration.Value)
			}
		}
		pl.Tracks = append(pl.Tracks, track)
	}
	return
}

func (pl *Playlist) WriteASX(w io.Writer) (num int64, err error) {
	var asx Asx
	asx.Version = "3.0"
	asx.Title = pl.Title

	const sep = string(filepath.Separator)
	var dir0 = filepath.Clean(pl.Dest)
	var dir1 = filepath.Dir(dir0)
	dir0 += sep
	dir1 += sep
	for _, track := range pl.Tracks {
		var fpath = track.Location
		if strings.HasPrefix(fpath, dir0) || strings.HasPrefix(fpath, dir1) {
			if fpath, err = filepath.Rel(dir0, fpath); err != nil {
				return
			}
		}
		var v AsxEntry
		v.Title = track.Title
		v.Ref.Href = fpath
		if track.Duration != 0 {
			if track.Duration > 0 {
				v.Duration.Value = ToHHMMSS(track.Duration)
			} else {
				v.Duration.Value = "-1"
			}
		}
		asx.Entry = append(asx.Entry, v)
	}

	var body []byte
	if body, err = xml.MarshalIndent(&asx, "", xmlindent); err != nil {
		return
	}
	var n int
	n, err = w.Write(body)
	num = int64(n)
	return
}

func (pl *Playlist) ReadXSPF(r io.Reader) (num int64, err error) {
	var body []byte
	if body, err = io.ReadAll(r); err != nil {
		return
	}
	num = int64(len(body))

	var xspf Xspf
	if err = xml.Unmarshal(body, &xspf); err != nil {
		return
	}

	pl.Title = xspf.Title

	for _, v := range xspf.Track {
		var track Track
		track.Title = v.Title
		track.Duration = v.Duration
		track.Location = pl.AbsPath(v.Location)
		pl.Tracks = append(pl.Tracks, track)
	}
	return
}

func (pl *Playlist) WriteXSPF(w io.Writer) (num int64, err error) {
	var xspf Xspf
	xspf.Version = "1.0"
	xspf.Xmlns = "http://xspf.org/ns/0/"
	xspf.Title = pl.Title

	const sep = string(filepath.Separator)
	var dir0 = filepath.Clean(pl.Dest)
	var dir1 = filepath.Dir(dir0)
	dir0 += sep
	dir1 += sep
	for _, track := range pl.Tracks {
		var fpath = track.Location
		if strings.HasPrefix(fpath, dir0) || strings.HasPrefix(fpath, dir1) {
			if fpath, err = filepath.Rel(dir0, fpath); err != nil {
				return
			}
		} else if !isURL(fpath) {
			fpath = "file:///" + fpath
		}
		var v XspfTrack
		v.Title = track.Title
		v.Location = fpath
		v.Duration = track.Duration
		xspf.Track = append(xspf.Track, v)
	}

	var body []byte
	if body, err = xml.MarshalIndent(&xspf, "", xmlindent); err != nil {
		return
	}
	var n int
	n, err = w.Write(body)
	num = int64(n)
	return
}

// The End.
