package hms

import (
	"bufio"
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/beevik/guid"
	"github.com/go-ini/ini"
)

type Track struct {
	Time int64
	Name string
	Path string
}

type Playlist struct {
	Tracks []Track
	Dest   string // playlist file destination
	Title  string
}

// Generated by https://www.onlinetool.io/xmltogo/

type WplMeta struct {
	Text    string `xml:",chardata"`
	Name    string `xml:"name,attr"`
	Content string `xml:"content,attr"`
}

type WplMedia struct {
	Text string `xml:",chardata"`
	Src  string `xml:"src,attr"`
	Tid  string `xml:"tid,attr,omitempty"`
}

type Wpl struct {
	XMLName xml.Name `xml:"smil"`
	Text    string   `xml:",chardata"`
	Head    struct {
		Text  string    `xml:",chardata"`
		Meta  []WplMeta `xml:"meta"`
		Title string    `xml:"title"`
	} `xml:"head"`
	Body struct {
		Text string `xml:",chardata"`
		Seq  struct {
			Text  string     `xml:",chardata"`
			Media []WplMedia `xml:"media"`
		} `xml:"seq"`
	} `xml:"body"`
}

type AsxParam struct {
	Text  string `xml:",chardata"`
	Name  string `xml:"name,attr"`
	Value string `xml:"value,attr"`
}

type AsxEntry struct {
	Text  string `xml:",chardata"`
	Title string `xml:"title,omitempty"`
	Ref   struct {
		Href string `xml:"href,attr"`
	} `xml:"ref"`
	Param     []AsxParam `xml:"param"`
	Author    string     `xml:"author,omitempty"`
	Copyright string     `xml:"copyright,omitempty"`
}

type Asx struct {
	XMLName xml.Name   `xml:"asx"`
	Text    string     `xml:",chardata"`
	Version string     `xml:"version,attr"`
	Title   string     `xml:"title,omitempty"`
	Param   []AsxParam `xml:"param"`
	Entry   []AsxEntry `xml:"entry"`
}

var (
	ErrM3USign = errors.New("file does not starts with M3U signature")
)

func isURL(fpath string) bool {
	return strings.HasPrefix(fpath, "http://") || strings.HasPrefix(fpath, "https://")
}

func (pl *Playlist) ReadFrom(r io.Reader) (num int64, err error) {
	return pl.ReadM3U(r)
}

func (pl *Playlist) WriteTo(w io.Writer) (num int64, err error) {
	return pl.WriteM3U(w)
}

func (pl *Playlist) ReadM3U(r io.Reader) (num int64, err error) {
	var buf = bufio.NewReader(r)
	var line string

	var readline = func() {
		for {
			line, err = buf.ReadString('\n')
			num += int64(len(line))
			if err != nil {
				if err == io.EOF {
					err = nil
				}
				return
			}
			line = strings.TrimSpace(line)
			if len(line) > 0 {
				break
			}
		}
	}

	if readline(); err != nil {
		return
	}
	if line != "#EXTM3U" && line != utf8bom+"#EXTM3U" {
		return 0, ErrM3USign
	}

	for {
		var track Track

		if readline(); err != nil || len(line) == 0 {
			return
		}

		if strings.HasPrefix(line, "#EXTINF") {
			if _, err = fmt.Sscanf(line, "#EXTINF:%d,%s", &track.Time, &track.Name); err != nil {
				return
			}

			if readline(); err != nil || len(line) == 0 {
				return
			}
			if filepath.IsAbs(line) || isURL(line) {
				track.Path = line
			} else if line[0] == filepath.Separator {
				track.Path = filepath.Join(filepath.VolumeName(pl.Dest), line)
			} else {
				track.Path = filepath.Join(pl.Dest, line)
			}
			pl.Tracks = append(pl.Tracks, track)
		} else if strings.HasPrefix(line, "#PLAYLIST:") {
			if _, err = fmt.Sscanf(line, "#PLAYLIST:%s", &pl.Title); err != nil {
				return
			}
		} else if strings.HasPrefix(line, "#") { // any other comment
			continue
		} else {
			if filepath.IsAbs(line) || isURL(line) {
				track.Path = line
			} else if line[0] == filepath.Separator {
				track.Path = filepath.Join(filepath.VolumeName(pl.Dest), line)
			} else {
				track.Path = filepath.Join(pl.Dest, line)
			}
			pl.Tracks = append(pl.Tracks, track)
		}
	}
}

func (pl *Playlist) WriteM3U(w io.Writer) (num int64, err error) {
	var n int
	n, err = fmt.Fprintln(w, "#EXTM3U")
	num += int64(n)
	if err != nil {
		return
	}

	if len(pl.Title) > 0 {
		n, err = fmt.Fprintf(w, "#PLAYLIST:%s\n", pl.Title)
		num += int64(n)
		if err != nil {
			return
		}
	}

	const sep = string(filepath.Separator)
	var dir0 = filepath.Clean(pl.Dest)
	var dir1 = filepath.Dir(dir0)
	dir0 += sep
	dir1 += sep
	for _, track := range pl.Tracks {
		if track.Time > 0 {
			n, err = fmt.Fprintf(w, "#EXTINF:%d,%s\n", track.Time, track.Name)
			num += int64(n)
			if err != nil {
				return
			}
		}

		var fpath = track.Path
		if strings.HasPrefix(fpath, dir0) || strings.HasPrefix(fpath, dir1) {
			if fpath, err = filepath.Rel(dir0, fpath); err != nil {
				return
			}
		}
		n, err = fmt.Fprintln(w, fpath)
		num += int64(n)
		if err != nil {
			return
		}
	}
	return
}

func (pl *Playlist) WriteM3U8(w io.Writer) (num int64, err error) {
	var n int
	var n64 int64
	n, err = w.Write([]byte(utf8bom))
	num += int64(n)
	if err != nil {
		return
	}
	n64, err = pl.WriteM3U(w)
	num += n64
	return
}

func (pl *Playlist) ReadWPL(r io.Reader) (num int64, err error) {
	var body []byte
	if body, err = io.ReadAll(r); err != nil {
		return
	}
	num = int64(len(body))

	var wpl Wpl
	if err = xml.Unmarshal(body, &wpl); err != nil {
		return
	}

	for _, v := range wpl.Body.Seq.Media {
		var track Track
		track.Name = filepath.Base(v.Src)
		if filepath.IsAbs(v.Src) || isURL(v.Src) {
			track.Path = v.Src
		} else if v.Src[0] == filepath.Separator {
			track.Path = filepath.Join(filepath.VolumeName(pl.Dest), v.Src)
		} else {
			track.Path = filepath.Join(pl.Dest, v.Src)
		}
		pl.Tracks = append(pl.Tracks, track)
	}
	return
}

func (pl *Playlist) WriteWPL(w io.Writer) (num int64, err error) {
	var n int
	n, err = fmt.Fprintln(w, `<?wpl version="1.0"?>`)
	num += int64(n)
	if err != nil {
		return
	}

	var wpl Wpl
	wpl.Head.Title = pl.Title
	wpl.Head.Meta = append(wpl.Head.Meta, WplMeta{Name: "Generator", Content: "Home Media Server"})
	wpl.Head.Meta = append(wpl.Head.Meta, WplMeta{Name: "ItemCount", Content: fmt.Sprintf("%d", len(pl.Tracks))})

	const sep = string(filepath.Separator)
	var dir0 = filepath.Clean(pl.Dest)
	var dir1 = filepath.Dir(dir0)
	dir0 += sep
	dir1 += sep
	for _, track := range pl.Tracks {
		var fpath = track.Path
		if strings.HasPrefix(fpath, dir0) || strings.HasPrefix(fpath, dir1) {
			if fpath, err = filepath.Rel(dir0, fpath); err != nil {
				return
			}
		}
		var g = guid.New()
		wpl.Body.Seq.Media = append(wpl.Body.Seq.Media, WplMedia{Src: fpath, Tid: "{" + g.StringUpper() + "}"})
	}

	var body []byte
	if body, err = xml.MarshalIndent(&wpl, "", "    "); err != nil {
		return
	}
	n, err = w.Write(body)
	num = int64(n)
	return
}

func (pl *Playlist) ReadPLS(r io.Reader) (num int64, err error) {
	var file *ini.File
	if file, err = ini.Load(r); err != nil {
		return
	}

	var pls *ini.Section
	if pls, err = file.GetSection("playlist"); err != nil {
		return
	}

	var key *ini.Key
	if key, err = pls.GetKey("NumberOfEntries"); err != nil {
		return
	}
	var count int64
	if count, err = key.Int64(); err != nil {
		return
	}

	for i := int64(1); i <= count; i++ {
		var track Track
		var sn = strconv.FormatInt(i, 10)

		if key, err = pls.GetKey("Length" + sn); err != nil {
			return
		}
		if track.Time, err = key.Int64(); err != nil {
			return
		}

		if key, err = pls.GetKey("Title" + sn); err != nil {
			return
		}
		track.Name = key.String()

		if key, err = pls.GetKey("File" + sn); err != nil {
			return
		}
		var fpath = key.String()
		if filepath.IsAbs(fpath) || isURL(fpath) {
			track.Path = fpath
		} else if fpath[0] == filepath.Separator {
			track.Path = filepath.Join(filepath.VolumeName(pl.Dest), fpath)
		} else {
			track.Path = filepath.Join(pl.Dest, fpath)
		}

		pl.Tracks = append(pl.Tracks, track)
	}
	return
}

func (pl *Playlist) WritePLS(w io.Writer) (num int64, err error) {
	var n int
	n, err = fmt.Fprintln(w, `[playlist]`)
	num += int64(n)
	if err != nil {
		return
	}
	const sep = string(filepath.Separator)
	var dir0 = filepath.Clean(pl.Dest)
	var dir1 = filepath.Dir(dir0)
	dir0 += sep
	dir1 += sep
	for i, track := range pl.Tracks {
		var fpath = track.Path
		if strings.HasPrefix(fpath, dir0) || strings.HasPrefix(fpath, dir1) {
			if fpath, err = filepath.Rel(dir0, fpath); err != nil {
				return
			}
		}
		n, err = fmt.Fprintf(w, "File%d=%s\n", i, fpath)
		num += int64(n)
		if err != nil {
			return
		}
		if len(track.Name) > 0 {
			n, err = fmt.Fprintf(w, "Title%d=%s\n", i, track.Name)
			num += int64(n)
			if err != nil {
				return
			}
		}
		if track.Time > 0 {
			n, err = fmt.Fprintf(w, "Length%d=%d\n", i, track.Time)
			num += int64(n)
			if err != nil {
				return
			}
		}
	}

	n, err = fmt.Fprintf(w, "NumberOfEntries=%d\n", len(pl.Tracks))
	num += int64(n)
	if err != nil {
		return
	}

	n, err = fmt.Fprintln(w, "Version=2")
	num += int64(n)
	if err != nil {
		return
	}
	return
}

func (pl *Playlist) ReadASX(r io.Reader) (num int64, err error) {
	var body []byte
	if body, err = io.ReadAll(r); err != nil {
		return
	}
	num = int64(len(body))

	var asx Asx
	if err = xml.Unmarshal(body, &asx); err != nil {
		return
	}

	for _, v := range asx.Entry {
		var track Track
		track.Name = v.Title
		if filepath.IsAbs(v.Ref.Href) || isURL(v.Ref.Href) {
			track.Path = v.Ref.Href
		} else if v.Ref.Href[0] == filepath.Separator {
			track.Path = filepath.Join(filepath.VolumeName(pl.Dest), v.Ref.Href)
		} else {
			track.Path = filepath.Join(pl.Dest, v.Ref.Href)
		}
		pl.Tracks = append(pl.Tracks, track)
	}
	return
}

func (pl *Playlist) WriteASX(w io.Writer) (num int64, err error) {
	var asx Asx
	asx.Version = "3.0"
	asx.Title = pl.Title

	const sep = string(filepath.Separator)
	var dir0 = filepath.Clean(pl.Dest)
	var dir1 = filepath.Dir(dir0)
	dir0 += sep
	dir1 += sep
	for _, track := range pl.Tracks {
		var fpath = track.Path
		if strings.HasPrefix(fpath, dir0) || strings.HasPrefix(fpath, dir1) {
			if fpath, err = filepath.Rel(dir0, fpath); err != nil {
				return
			}
		}
		var v AsxEntry
		v.Title = track.Name
		v.Ref.Href = track.Path
		asx.Entry = append(asx.Entry, v)
	}

	var body []byte
	if body, err = xml.MarshalIndent(&asx, "", "    "); err != nil {
		return
	}
	var n int
	n, err = w.Write(body)
	num = int64(n)
	return
}

// The End.
